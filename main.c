/******************************************************************************
 * File Name:   main.c
 *
 * Description: main.c for the EIS Controller board
 *
 *
 *
 ******************************************************************************
 *
 * Copyright (c) 2015-2021, Infineon Technologies AG All rights reserved.
 *
 * Boost Software License - Version 1.0 - August 17th, 2003
 *
 * Permission is hereby granted, free of charge, to any person or organization obtaining a copy of the software and
 *accompanying documentation covered by this license (the "Software") to use, reproduce, display, distribute, execute,
 *and transmit the Software, and to prepare derivative works of the Software, and to permit third-parties to whom the
 *Software is furnished to do so, all subject to the following:
 *
 * The copyright notices in the Software and this entire statement, including the above license grant, this restriction
 *and the following disclaimer, must be included in all copies of the Software, in whole or in part, and all derivative
 *works of the Software, unless such copies or derivative works are solely in the form of machine-executable object code
 *generated by a source language processor.
 *
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE
 *WARRANTIES OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE, TITLE AND NON-INFRINGEMENT. IN NO EVENT SHALL THE
 *COPYRIGHT HOLDERS OR ANYONE DISTRIBUTING THE SOFTWARE BE LIABLE FOR ANY DAMAGES OR OTHER LIABILITY, WHETHER IN
 *CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
 *THE SOFTWARE.
 *
 *****************************************************************************/

#include "cy_utils.h"
#include "cybsp.h"
#include "cycfg_peripherals.h"
#include "modes_states_pins.h"
#include "uart_control.h"
#include <XMC1100.h>
#include <stdint.h>
#include <xmc_scu.h>
#include <xmc_uart.h>
#include <xmc_usic.h>
#include <xmc_wdt.h>


// Betriebsmodus Variable
static mode_t mode = MODE_IDLE;
// Zustands variable
static uint16_t state     = 0;

void ccu4_0_SR0_INTERRUPT_HANDLER() {
  // Ändern des Zustands in abhängikeit von Betriebsmodus und Zustand
  XMC_CCU4_SLICE_ClearEvent(timerFreq_HW, XMC_CCU4_SLICE_IRQ_ID_COMPARE_MATCH_UP);

  // Wenn der letzte Zustand ereicht ist, wird von vorne begonnen, ansonsten wird der Zustand inkrementiert
  state      = (state == 3) ? 0 : state + 1;
  // MC Ausgang beschreiben
  PORT0->OMR = lookupMatrix[mode][state];
}

void ccu4_0_SR1_INTERRUPT_HANDLER() {
  // Ändern des Zustands in abhängikeit von Betriebsmodus und Zustand
  XMC_CCU4_SLICE_ClearEvent(timerFreq_HW, XMC_CCU4_SLICE_IRQ_ID_PERIOD_MATCH);

  // Wenn der letzte Zustand ereicht ist, wird von vorne begonnen, ansonsten wird der Zustand inkrementiert
  state      = (state == 3) ? 0 : state + 1;
  // MC Ausgang beschreiben
  PORT0->OMR = lookupMatrix[mode][state];
}

void ccu4_0_SR2_INTERRUPT_HANDLER() {
  // Interupt handler nachdem periodCountValue ereicht ist (Wird für jeden compare und period Match erhöht)
  XMC_CCU4_SLICE_ClearEvent(timerPeriodCount_HW, XMC_CCU4_SLICE_IRQ_ID_PERIOD_MATCH);
  stopStimulation(&mode, &state);
}

void uart_RECEIVE_BUFFER_STANDARD_EVENT_HANDLER() {
  XMC_USIC_CH_RXFIFO_ClearEvent(uart_HW, XMC_USIC_CH_RXFIFO_EVENT_STANDARD);

  uint8_t receivedData[4];
  uint8_t rxIndex = 0;

  // Wenn keine Steurungs Daten Interrupt Handler verlassen um Fehler zu vermeiden
  if (XMC_USIC_CH_RXFIFO_IsEmpty(uart_HW)) {
    return;
  }

  // Lesen der Daten bis der Input Puffer leer ist und maximal 4 Bytes Empfangen wurden
  while ((!XMC_USIC_CH_RXFIFO_IsEmpty(uart_HW)) && rxIndex < 4) {
    receivedData[rxIndex++] = XMC_UART_CH_GetReceivedData(uart_HW);
  }

  // Wenn RXFIFO nicht leer weil zu viele Daten -> Leeren
  if (!XMC_USIC_CH_RXFIFO_IsEmpty(uart_HW)) {
    XMC_USIC_CH_RXFIFO_Flush(uart_HW);
  }

  // Empfangen Daten zurückschreiben
  // Signal Start
  XMC_UART_CH_Transmit(uart_HW, '\n');

  for (int i = 0; i < rxIndex; i++) {
    XMC_UART_CH_Transmit(uart_HW, receivedData[i]);
  }
  
  //Signal Stopp
  XMC_UART_CH_Transmit(uart_HW, '\n');

  // Frequenz wert aus den letzten empfangenen bytes zusammen setzen
  uint16_t newFrequency = (receivedData[0] << 8) + receivedData[1];
  uint8_t dutyCycle = receivedData[2];
  // Anzahl der Perioden
  uint8_t periodCount = receivedData[3];

  // Auswertung der Empgangen Daten
  uartCommandEvaluation(&newFrequency, &dutyCycle, &periodCount, &mode, &state);
}


int main(void) {
  cy_rslt_t result;

  /* Initialize the device and board
   * peripherals */
  result = cybsp_init();
  if (result != CY_RSLT_SUCCESS) {
    CY_ASSERT(0);
  }

  // Wenn der letzte Reset vom Watchdog Timer verursacht wurde sicheren Zustand herstellen
  if (XMC_SCU_RESET_REASON_WATCHDOG & XMC_SCU_RESET_GetDeviceResetReason()) {
    mode       = MODE_IDLE;
    PORT0->OMR = MODE_IDLE_OUT;
    XMC_SCU_RESET_ClearDeviceResetReason();
    // Dauerschleife bis zum neuen Reset
    while (true) {
      XMC_WDT_Service();
      XMC_UART_CH_Transmit(uart_HW, 'x');
    }
  }

  // Start Betriebsmodus
  mode       = MODE_IDLE;
  // Start Ausgabe
  PORT0->OMR = MODE_IDLE_OUT;

  // Sicherstellen das der RXFIFO leer ist
  XMC_USIC_CH_RXFIFO_Flush(uart_HW);

  NVIC_SetPriority(ccu4_0_SR0_IRQN, 0U);
  NVIC_EnableIRQ(ccu4_0_SR0_IRQN);

  NVIC_SetPriority(ccu4_0_SR1_IRQN, 0U);
  NVIC_EnableIRQ(ccu4_0_SR1_IRQN);

  NVIC_SetPriority(ccu4_0_SR2_IRQN, 1U);
  NVIC_EnableIRQ(ccu4_0_SR2_IRQN);

  NVIC_SetPriority(uart_RECEIVE_BUFFER_STANDARD_EVENT_IRQN, 2U);
  NVIC_EnableIRQ(uart_RECEIVE_BUFFER_STANDARD_EVENT_IRQN);

  // Senden das MC bereit
  XMC_UART_CH_Transmit(uart_HW, 0x40);

  for (;;) {
    XMC_WDT_Service();
  }
}

/* [] END OF FILE */
